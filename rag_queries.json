[
  {
    "question": "How is posting validated?",
    "answer": "Posting is validated within the `validate` method of the document. This method performs various checks, including:\n\n*   **Stock Quantities:** Ensuring no negative stock (`validate_for_negative_stock`), validating stock in hand quantities (`validate_stock_in_hand_qty`), and validating stock entry item quantities (`validate_stock_entry_qty`).\n*   **Item & Warehouse:** Verifying item codes and warehouses (`validate_item_code_and_warehouse`).\n*   **UOM:** Validating UOM conversion factors (`validate_uom_conversion_factor`).\n*   **Batch/Serial:** Ensuring batch and serial numbers are correct (`validate_batch_serial_no`).\n*   **Document Specific:** Performing specific validations for document types like \"Purchase Receipt\" (e.g., `validate_over_billing_for_purchase_receipt`) and \"Stock Entry\" (e.g., `validate_stock_and_cost_center_for_stock_entry`).\n*   **Account:** Validating accounts for amounts (`validate_account_for_amount`)."
  },
  {
    "question": "How is posting validated?",
    "answer": "Posting is validated through the `validate_posting_allowed` method, which performs the following checks:\n\n1.  **Date and Time Presence:** Ensures `posting_date` and `posting_time` are provided.\n2.  **Cancelled Document Transactions:** If the document is cancelled (`docstatus == 2`), it verifies if `get_allow_transactions_against_cancelled_document` permits operations against the doctype.\n3.  **Submittable Document Specific Checks (if not an opening entry):**\n    *   **Period Freezing:** If the document is a draft (`docstatus == 0`), it calls `self.check_is_frozen(self.posting_date)`.\n    *   **Back-dated Transactions:** If a draft, it calls `self.validate_back_dated_transactions(self.posting_date, self.posting_time)`.\n    *   **Cancelled and Amended Status:** Calls `self.validate_cancelled_and_amended()`.\n    *   **Future-dated Transactions:** Calls `self.validate_future_dated_transactions(posting_datetime)`."
  },
  {
    "question": "Where are validation errors raised?",
    "answer": "Based on the provided (empty) context, it is not possible to determine where validation errors are raised."
  },
  {
    "question": "How is posting validated?",
    "answer": "Posting validation occurs during the `before_insert` and `before_save` hooks of a document. Key validations performed include:\n\n1.  **Posting Date Validation (`validate_posting_date`):** Checks if the posting date is valid, within the fiscal year, and not a future date if `allow_future_date_posting` is disabled for the Company.\n2.  **Cost Center Validation (`validate_cost_center`):** If cost centers are enabled for the Company, ensures all non-zero value accounts linked to the company have a cost center assigned.\n3.  **General Ledger (GL) Entry Integrity:**\n    *   Confirms that if a GL entry has a debit or credit value, its `account` field is populated.\n    *   Checks the `finance_book` field if `is_opening` is true.\n    *   **Balances Debits and Credits:** Verifies that the total debit amount precisely equals the total credit amount across all GL entries.\n4.  **Maximum Discount Validation (`validate_max_discount`):** Checks if the specified item discount percentage exceeds the allowed maximum.\n\nAny validation failure raises a `ValidationError`."
  },
  {
    "question": "Where are validation errors raised?",
    "answer": "Based on the provided context, there is no information about where validation errors are raised."
  },
  {
    "question": "Where are validation errors raised?",
    "answer": "Validation errors are raised using:\n\n1.  **`frappe.throw`**:\n    *   In `Purchase Invoice` within `set_expense_account`, `po_required`, `pr_required`, `validate_write_off_account`, `check_prev_docstatus`, and `validate_purchase_receipt_if_update_stock`.\n    *   In `Stock Ledger` within `validate_reserved_stock`, `validate_reserved_serial_nos`, and `validate_reserved_batch_nos`.\n    *   In `Stock Entry` within `validate_subcontract_order`, `validate_purchase_order`, `validate_finished_goods`, and `validate_serial_batch_bundle_type`.\n2.  **`frappe.msgprint(..., raise_exception=True)`**:\n    *   In `Purchase Invoice` within `validate_item_code` and `set_expense_account`.\n\nTest files also use `self.assertRaises(frappe.exceptions.ValidationError, ...)` to *verify* that validation errors are raised by methods like `pr.submit()` or `repost_doc.save()`."
  },
  {
    "question": "Which methods are called before submitting a document?",
    "answer": "Based on the provided code context, when creating a Subcontracting Order (`target_doc`) from a Purchase Order:\n\nThe `target_doc.save()` method is called immediately before `target_doc.submit()`."
  },
  {
    "question": "What validation and lifecycle methods run before and during document submission in ERPNext?",
    "answer": "Before and during document submission, the following validation and lifecycle methods run:\n\n**1. Before Submission (during the `validate` hook):**\n\n*   **`InstallationNote.validate()`** (calls its own specific validations):\n    *   `self.validate_installation_date()`: Ensures installation date is not before the delivery date for items.\n    *   `self.check_item_table()`: Verifies that items have been pulled from a Delivery Note.\n    *   `erpnext.controllers.selling_controller.set_default_income_account_for_item(self)`\n*   **`TransactionBase.validate_posting_time()`**: Ensures posting date and time are valid, setting them to `now_datetime()` if `set_posting_time` is not enabled.\n*   **`TransactionBase.validate_uom_is_integer(self, uom_field, qty_fields, child_dt=None)`**: Validates that UOM quantities are integers.\n*   **`TransactionBase.validate_with_previous_doc(self, ref)`**: Compares current document values with linked previous documents, calling `compare_values` for detailed checks.\n*   **`TransactionBase.validate_rate_with_reference_doc(self, ref_details)`**: Checks if item rates are consistent with reference documents based on Buying/Selling Settings, potentially stopping submission or issuing warnings.\n*   **`TransactionBase.validate_currency_for_receivable_payable_and_advance_account()`**: Validates that currencies of Receivable/Payable and Advance Accounts match the document's default currency or the company's default currency.\n\n**2. During Submission (during the `on_submit` hook):**\n\n*   **`InstallationNote.on_submit()`**:\n    *   `self.validate_serial_no()`: Validates serial numbers for items, checking if they are added, exist, and match those from the previous Delivery Note.\n    *   `self.update_prevdoc_status()`: Updates the status of linked previous documents (e.g., Delivery Note).\n    *   `self.db_set(\"status\", \"Submitted\")`: Sets the document's status in the database to \"Submitted\"."
  },
  {
    "question": "How is validation done?",
    "answer": "Validation is primarily performed through:\n\n1.  **DocType-Specific `validate` methods:** Many DocType classes (e.g., `Item`, `SupplierScorecardCriteria`, `StatusUpdater`) implement `validate` or `validate_*` methods. These methods contain business logic checks relevant to the specific DocType.\n    *   **Examples:**\n        *   `Item.validate_attributes()`: Checks for mandatory attributes and duplicates.\n        *   `Item.cant_change()`: Prevents modification of restricted fields if linked submitted documents exist.\n        *   `SupplierScorecardCriteria.validate_formula()`: Evaluates formulas using `frappe.safe_eval` to ensure validity.\n        *   `StatusUpdater.validate_qty()`: Checks for negative quantities, rates, and validates against over-receipt/delivery/billing allowances.\n\n2.  **Utility Validation Functions:** Standalone functions prefixed with `validate_` are used to perform specific checks across different contexts.\n    *   **Examples:**\n        *   `validate_end_of_life(item_code, ...)`: Checks if an item has reached its end-of-life or is disabled.\n        *   `validate_is_stock_item(item_code, ...)`: Ensures an item is a stock item.\n        *   `validate_reserved_stock(kwargs)`: Checks against reserved stock quantities.\n        *   `validate_status(status, options)`: Ensures a status is one of the allowed options.\n\n3.  **Input Parameter Validation:** Direct checks on incoming data or form inputs.\n    *   **Example:** In `erpnext\\www\\book_appointment\\verify\\index.py`, `email` and `appointment_name` are checked for existence.\n\n4.  **System-Level Request Verification:** Utilizes `frappe.utils.verified_command.verify_request()` for security.\n\n**Mechanism of Validation:**\n\n*   **Error Raising:** The primary mechanism for indicating a validation failure is `frappe.throw()`, which halts execution and displays an error message to the user. Specific `ValidationError` subclasses like `OverAllowanceError` or `InvalidFormulaVariable` can be used.\n*   **Warnings/Soft Failures:** For less critical issues, `frappe.msgprint()` is used to display an alert or warning without stopping the transaction (e.g., `validate_auto_reorder_enabled_in_stock_settings`, `warn_about_bypassing_with_role`).\n*   **Data Consistency Checks:** Queries are often made against the database to ensure new data adheres to existing records (e.g., checking `stock_uom` against `Stock Ledger Entry` or `Bin` records in `check_stock_uom_with_bin`)."
  },
  {
    "question": "How is validation done?",
    "answer": "Validation is primarily performed through:\n\n1.  **DocType-Specific `validate` methods:** Many DocType classes (e.g., `Item`, `SupplierScorecardCriteria`, `StatusUpdater`) implement `validate` or `validate_*` methods. These methods contain business logic checks relevant to the specific DocType.\n    *   **Examples:**\n        *   `Item.validate_attributes()`: Checks for mandatory attributes and duplicates.\n        *   `Item.cant_change()`: Prevents modification of restricted fields if linked submitted documents exist.\n        *   `SupplierScorecardCriteria.validate_formula()`: Evaluates formulas using `frappe.safe_eval` to ensure validity.\n        *   `StatusUpdater.validate_qty()`: Checks for negative quantities, rates, and validates against over-receipt/delivery/billing allowances.\n\n2.  **Utility Validation Functions:** Standalone functions prefixed with `validate_` are used to perform specific checks across different contexts.\n    *   **Examples:**\n        *   `validate_end_of_life(item_code, ...)`: Checks if an item has reached its end-of-life or is disabled.\n        *   `validate_is_stock_item(item_code, ...)`: Ensures an item is a stock item.\n        *   `validate_reserved_stock(kwargs)`: Checks against reserved stock quantities.\n        *   `validate_status(status, options)`: Ensures a status is one of the allowed options.\n\n3.  **Input Parameter Validation:** Direct checks on incoming data or form inputs.\n    *   **Example:** In `erpnext\\www\\book_appointment\\verify\\index.py`, `email` and `appointment_name` are checked for existence.\n\n4.  **System-Level Request Verification:** Utilizes `frappe.utils.verified_command.verify_request()` for security.\n\n**Mechanism of Validation:**\n\n*   **Error Raising:** The primary mechanism for indicating a validation failure is `frappe.throw()`, which halts execution and displays an error message to the user. Specific `ValidationError` subclasses like `OverAllowanceError` or `InvalidFormulaVariable` can be used.\n*   **Warnings/Soft Failures:** For less critical issues, `frappe.msgprint()` is used to display an alert or warning without stopping the transaction (e.g., `validate_auto_reorder_enabled_in_stock_settings`, `warn_about_bypassing_with_role`).\n*   **Data Consistency Checks:** Queries are often made against the database to ensure new data adheres to existing records (e.g., checking `stock_uom` against `Stock Ledger Entry` or `Bin` records in `check_stock_uom_with_bin`)."
  },
  {
    "question": "How are taxes calculated?",
    "answer": "No relevant code found for the given scope."
  },
  {
    "question": "How are taxes calculated?",
    "answer": "No relevant code found for the given scope."
  },
  {
    "question": "How are taxes calculated?",
    "answer": "No relevant code found for the given scope."
  },
  {
    "question": "How are taxes calculated?",
    "answer": "No relevant code found for the given scope."
  },
  {
    "question": "How are taxes calculated?",
    "answer": "No relevant code found for the given scope."
  },
  {
    "question": "How are taxes calculated?",
    "answer": "Taxes are calculated by iterating through each tax and each item in the document.\n\n1.  **Item-wise Calculation**: The `get_current_tax_and_net_amount` method determines `current_tax_amount` and `current_net_amount` for each item based on the `tax.charge_type`:\n    *   **Actual**: `tax.tax_amount` is proportionally distributed by `item.net_amount`.\n    *   **On Net Total**: `tax_rate` is applied to `item.net_amount`.\n    *   **On Previous Row Amount**: `tax_rate` is applied to the `tax_amount_for_current_item` of the referenced previous tax row.\n    *   **On Previous Row Total**: `tax_rate` is applied to the `grand_total_for_current_item` of the referenced previous tax row.\n    *   **On Item Quantity**: `tax_rate` is multiplied by `item.qty`.\n    *   For Payment Entries, `get_current_tax_amount` uses `self.paid_amount_after_tax` for \"On Paid Amount\" charges.\n    These item-wise tax breakups (amount, taxable amount) are stored in `doc._item_wise_tax_details`.\n\n2.  **Cumulative Totals**: The `set_cumulative_total` method calculates the running `tax.total` for each tax row.\n    *   The `tax.tax_amount_after_discount_amount` is first adjusted: it's set to `0.0` if `tax.category` is \"Valuation\", and negated if `tax.add_deduct_tax` is \"Deduct\" in purchase documents.\n    *   The first tax row's `total` is `doc.net_total + adjusted_tax_amount`.\n    *   Subsequent rows' `total` is the previous row's `total + adjusted_tax_amount`.\n\n3.  **Rounding**: `round_off_totals` and `round_off_base_values` apply rounding to `tax_amount`, `tax_amount_after_discount_amount`, and `net_amount` (and their base equivalents) if the `account_head` is configured in `frappe.flags.round_off_applicable_accounts`.\n\n4.  **Discount Application**: If `doc.discount_amount` is set and `doc.apply_discount_on` is not \"Grand Total\" (and not a cash/non-trade discount), the `apply_discount_amount` method distributes the discount proportionally across items, adjusting `item.net_amount` and triggering a recalculation.\n\n5.  **Final Document Totals**: `calculate_totals` sets the `doc.grand_total` based on the `total` of the last tax row (with potential `grand_total_diff` adjustments) and derives `doc.total_taxes_and_charges`. `set_rounded_total` then applies final rounding to `grand_total` to determine `rounded_total` and `rounding_adjustment`."
  },
  {
    "question": "How are taxes calculated?",
    "answer": "No relevant code found for the given scope."
  },
  {
    "question": "How are taxes calculated?",
    "answer": "Taxes are calculated based on the `charge_type` and `rate` defined for each tax item. The primary calculation logic resides in the `get_current_tax_amount` and `get_current_tax_fraction` methods within the `PaymentEntry` document.\n\nHere's how taxes are calculated:\n\n1.  **`paid_amount_after_tax`**: This base amount, used for \"On Paid Amount\" charge types, is derived from the `base_total` of the last tax item in the `self.taxes` list.\n\n2.  **`get_current_tax_amount(self, tax)`**:\n    *   **`Actual`**: The `tax.tax_amount` is used directly.\n    *   **`On Paid Amount`**: Calculated as `(tax.rate / 100.0) * self.paid_amount_after_tax`.\n    *   **`On Previous Row Amount`**: Calculated as `(tax.rate / 100.0) * self.get(\"taxes\")[cint(tax.row_id) - 1].tax_amount`. This requires `row_id` to refer to a preceding tax row.\n    *   **`On Previous Row Total`**: Calculated as `(tax.rate / 100.0) * self.get(\"taxes\")[cint(tax.row_id) - 1].total`. This also requires `row_id`.\n    *   **Validation**: \"On Previous Row Amount\" or \"On Previous Row Total\" cannot be selected for the first tax row (`tax.idx == 1`).\n\n3.  **`get_current_tax_fraction(self, tax)`**: This is calculated only if `tax.included_in_paid_amount` is true.\n    *   **`On Paid Amount`**: The fraction is `tax.rate / 100.0`.\n    *   **`On Previous Row Amount`**: Calculated as `(tax.rate / 100.0) * self.get(\"taxes\")[cint(tax.row_id) - 1].tax_fraction_for_current_item`.\n    *   **`On Previous Row Total`**: Calculated as `(tax.rate / 100.0) * self.get(\"taxes\")[cint(tax.row_id) - 1].grand_total_fraction_for_current_item`.\n    *   **Deduction**: If `tax.add_deduct_tax` is \"Deduct\", the `current_tax_fraction` is multiplied by -1.0.\n\n4.  **Inclusive Tax Validation (`validate_inclusive_tax`)**:\n    *   Taxes with `charge_type` \"Actual\" cannot be marked `included_in_paid_amount`.\n    *   If a tax is \"On Previous Row Amount\" or \"On Previous Row Total\" and `included_in_paid_amount` is set, the referred previous tax row(s) must also be inclusive.\n    *   Charges with `category` \"Valuation\" cannot be marked as `included_in_paid_amount`."
  },
  {
    "question": "How are taxes calculated?",
    "answer": "No relevant code found for the given scope."
  },
  {
    "question": "How are taxes calculated?",
    "answer": "Taxes are calculated item-wise, with the `calculate_taxes_and_totals` process orchestrating various steps.\n\n1.  **Item Net Amount Adjustment**: If a document-level `discount_amount` is applied, it's first distributed proportionally among items, adjusting each `item.net_amount`.\n2.  **Individual Tax Row Calculation (`get_current_tax_and_net_amount`)**:\n    *   For each tax row (`tax`) and item (`item`), a `current_tax_amount` is determined based on the `tax.charge_type`:\n        *   **\"Actual\"**: The total `tax.tax_amount` is distributed proportionally across `item.net_amount` based on `self.doc.net_total`.\n        *   **\"On Net Total\"**: `(tax_rate / 100.0) * item.net_amount`.\n        *   **\"On Previous Row Amount\"**: `(tax_rate / 100.0)` applied to the `tax_amount_for_current_item` of the tax row specified by `tax.row_id`.\n        *   **\"On Previous Row Total\"**: `(tax_rate / 100.0)` applied to the `grand_total_for_current_item` of the tax row specified by `tax.row_id`.\n        *   **\"On Item Quantity\"**: `tax_rate * item.qty`.\n3.  **Item-wise Tax Breakup (`set_item_wise_tax`)**: The `current_tax_amount` for each item and tax combination, along with its `taxable_amount`, is stored in `self.doc._item_wise_tax_details`. Tax amounts can be multiplied by -1 if `add_deduct_tax` is \"Deduct\".\n4.  **Discount Application to Tax Amount**: The calculated `current_tax_amount` for each tax row is then stored as `tax.tax_amount_after_discount_amount`, reflecting the impact of prior item net amount adjustments.\n5.  **Cumulative Total Calculation (`set_cumulative_total`)**:\n    *   The `tax.tax_amount_after_discount_amount` is first adjusted if the `tax.category` is \"Valuation\" (set to 0) or if `add_deduct_tax` is \"Deduct\" (multiplied by -1).\n    *   For the first tax row, `tax.total = doc.net_total + adjusted_tax_amount`.\n    *   For subsequent rows, `tax.total = previous_tax_row.total + adjusted_tax_amount`.\n6.  **Rounding (`round_off_totals`, `round_off_base_values`)**: Tax amounts and cumulative totals are rounded based on configured precision or regional settings (e.g., `round_off_applicable_accounts`).\n7.  **Item-wise Tax Details Reconciliation (`adjust_rounding_in_item_wise_tax_details`)**: Differences between the summed `_item_wise_tax_details` and the final `tax.base_tax_amount_after_discount_amount` for each tax row are adjusted by applying the `diff` to the `amount` of the last item-wise tax detail row for that tax.\n8.  **Final Grand Total Calculation (`calculate_totals`)**: The `doc.grand_total` is set from the `total` of the last tax row, plus any `grand_total_diff` (e.g., from inclusive tax adjustments).\n9.  **Rounded Total (`set_rounded_total`)**: The `grand_total` is then rounded to `doc.rounded_total` based on currency fractions, and `rounding_adjustment` is calculated."
  },
  {
    "question": "How are taxes calculated?",
    "answer": "Taxes are calculated through the following mechanisms within the Sales Invoice context:\n\n1.  **`calculate_taxes_and_totals` method**: This method is explicitly called during the creation of linked documents like Delivery Notes (e.g., `target.run_method(\"calculate_taxes_and_totals\")` in `make_delivery_note`), implying it's a core method for tax computation.\n2.  **`set_taxes()` method**: When setting POS fields, if a `taxes_and_charges` template is present and no taxes have been applied yet, `self.set_taxes()` is called to populate the `taxes` table.\n3.  **`update_taxes()` function**: For inter-company transactions, this helper function retrieves applicable `taxes_and_charges` and the `taxes` breakdown from `get_party_details()` based on the party, company, and address, then sets these values on the document."
  },
  {
    "question": "How are taxes calculated?",
    "answer": "Taxes are primarily calculated by the `get_current_tax_amount` method, which determines the `current_tax_amount` based on the `tax.charge_type`:\n\n1.  **Actual**: Uses the directly provided `tax.tax_amount`.\n2.  **On Paid Amount**: Calculates `(tax_rate / 100.0) * self.paid_amount_after_tax`.\n3.  **On Previous Row Amount**: Calculates `(tax_rate / 100.0) * self.get(\"taxes\")[cint(tax.row_id) - 1].tax_amount`.\n4.  **On Previous Row Total**: Calculates `(tax_rate / 100.0) * self.get(\"taxes\")[cint(tax.row_id) - 1].total`.\n    For \"On Previous Row Amount\" or \"On Previous Row Total,\" if `tax.row_id` is not set, it defaults to the `tax.idx - 1`.\n\nThe `get_current_tax_fraction` method calculates a fractional value (e.g., `tax_rate / 100.0`) when `tax.included_in_paid_amount` is true. This fraction is used for taxes that are included in the item rate or paid amount. If `tax.add_deduct_tax` is \"Deduct\", the fraction is multiplied by -1.0."
  },
  {
    "question": "Where are validation errors raised?",
    "answer": "Validation errors are raised in the following locations:\n\n**1. `erpnext/erpnext/accounts/doctype/purchase_invoice/purchase_invoice.py`**\n   - `validate_item_code`: If an item has no `item_code`.\n   - `set_expense_account`:\n     - If `Fixed Asset Account` is not set in `Asset Category` for a fixed asset item.\n     - If `expense_account` is mandatory and not set for an item.\n   - `po_required`: If a `Purchase Order` is required but not linked to an item.\n   - `pr_required`: If a `Purchase Receipt` is required but not linked to a stock item.\n   - `validate_write_off_account`: If `write_off_amount` is set but `write_off_account` is not.\n   - `check_prev_docstatus`: If a linked `Purchase Order` or `Purchase Receipt` is not submitted.\n   - `validate_purchase_receipt_if_update_stock`: If stock is updated against a `Purchase Receipt`.\n\n**2. `erpnext/erpnext/stock/doctype/stock_entry/stock_entry.py`**\n   - `validate_subcontract_order`:\n     - If a raw material item is not found in the 'Raw Materials Supplied' table of the linked `Subcontract Order`.\n     - If the transferred quantity of a raw material exceeds the allowed quantity against the `Subcontract Order`.\n     - If `subcontracted_item` is mandatory but missing, or if an item is not found in 'Raw Materials Supplied' table (without allowing alternatives).\n     - If `Subcontracted Item` is mandatory for a raw material when `backflush_raw_materials_based_on` is 'Material Transferred for Subcontract'.\n   - `validate_purchase_order`: If a \"Send to Subcontractor\" entry is made against a regular `Purchase Order` instead of a `Subcontracting Order`.\n   - `validate_finished_goods`:\n     - If a finished item does not match the `production_item` in the linked `Work Order`.\n     - If no item is marked as a finished good.\n     - If multiple items are marked as finished goods for a \"Manufacture\" purpose entry.\n     - If the `fg_completed_qty` exceeds the allowed overproduction quantity for the `Work Order`.\n   - `validate_serial_batch_bundle_type`: If the 'Type of Transaction' in the `Serial and Batch Bundle` is not 'Outward'.\n   - `validate_component_and_quantities`:\n     - If the quantity of a component item in the Stock Entry does not match the quantity specified in the `BOM`.\n     - If an item listed in the `BOM` is missing from the Stock Entry.\n   - `validate_same_source_target_warehouse_during_material_transfer`: If source and target warehouses are the same for a \"Material Transfer\" purpose and no inventory dimensions differ.\n   - `get_basic_rate_for_manufactured_item`:\n     - If raw materials are added to a \"Manufacture\" entry when `get_rm_cost_from_consumption_entry` is enabled.\n     - If more than one \"Manufacture\" entry is created against the same `Work Order` when `get_rm_cost_from_consumption_entry` is enabled.\n\n**3. `erpnext/erpnext/controllers/status_updater.py`**\n   - `validate_qty`:\n     - If an item quantity is negative for a non-return document, or positive for a return document.\n     - If an item's rate is negative and \"Allow Negative rates for Items\" is disabled in Selling Settings.\n   - `limits_crossed_error` (raises `OverAllowanceError`): If over-receipt/delivery or over-billing limits are crossed and the user's role does not allow bypassing these limits.\n\n**4. `erpnext/erpnext/stock/doctype/delivery_note/delivery_note.py`**\n   - `validate_packed_qty`: If `packed_qty` is not equal to `qty` for an item not part of a product bundle.\n   - `check_next_docstatus`: If a `Sales Invoice` or `Installation Note` has already been submitted against the `Delivery Note`.\n   - `make_return_invoice`: If an automatic credit note cannot be created.\n   - `validate_against_stock_reservation_entries`: If an item's warehouse in the Delivery Note does not match the reserved warehouses from a `Stock Reservation Entry` for a Sales Order.\n\n**5. `erpnext/erpnext/controllers/subcontracting_inward_controller.py`**\n   - `validate_material_receipt`:\n     - If an item is not marked as a \"Customer Provided Item\".\n     - If there is an item code mismatch for an existing `Subcontracting Inward Order Received Item`.\n     - If a \"Customer Provided Item\" against a \"Finished Good\" is added multiple times.\n     - If `against_fg` is not selected for an additional \"Customer Provided Item\".\n   - `validate_returns`:\n     - If an item is not part of the `Subcontracting Inward Order`.\n     - If there is an item code mismatch for an existing `Subcontracting Inward Order Item` or `Received Item`.\n     - If the returned quantity exceeds the available quantity to return.\n   - `validate_material_transfer`:\n     - If an item in the transfer is not a \"Customer Provided Item\".\n     - If the source warehouse for a \"Customer Provided Item\" is not the `customer_warehouse` from the linked `Subcontracting Inward Order`.\n     - If a \"Customer Provided Item\" is added multiple times in the same Stock Entry.\n     - If the transferred quantity of a \"Customer Provided Item\" leads to overconsumption against the `Work Order`.\n     - If a \"Customer Provided Item\" is not part of the `Work Order`.\n   - `validate_manufacture`:\n     - If the target warehouse for the finished good is not the `fg_warehouse` specified in the linked `Work Order`.\n     - If a \"Customer Provided Item\" quantity exceeds the available quantity through the `Subcontracting Inward Order`.\n     - If the source warehouse for a \"Customer Provided Item\" is not the `customer_warehouse`.\n     - If a \"Customer Provided Item\" is added multiple times.\n     - If a \"Customer Provided Item\" is not part of the `Subcontracting Inward Order` or `Work Order`.\n     - If the consumed quantity of a \"Customer Provided Item\" leads to overconsumption against the `Work Order`.\n   - `validate_warehouse_`: If the source or target warehouse for an item is not the `customer_warehouse` from the linked `Subcontracting Inward Order` for specific purposes.\n   - `validate_serial_batch_for_return_or_delivery`:\n     - If selected serial numbers are not part of the linked `Subcontracting Inward Order`.\n     - If selected batch numbers are not part of the linked `Subcontracting Inward Order`.\n   - `validate_delivery`: If the returned quantity in a `Subcontracting Inward Order Item` is greater than the delivered quantity during cancellation of a \"Subcontracting Delivery\" Stock Entry.\n   - `validate_delivery_on_save`: If an item is not part of the `Subcontracting Inward Order` during save/submit of a \"Subcontracting Delivery\" Stock Entry.\n\n**6. `erpnext/erpnext/stock/doctype/batch/test_batch.py`**\n   - **(Implicitly in Batch doctype logic)**: If `item_has_batch_enabled` is false for an item when creating a Batch (tested by `test_item_has_batch_enabled`).\n   - **(Implicitly in SerialBatchCreation logic)**: If an outgoing transaction leads to negative stock for a batch (tested by `test_batch_negative_stock_error` which catches `BatchNegativeStockError`)."
  }
]